<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
    	<title>Mikko Nummelin : MZ80TestBench - an open source Z80 test bench
    		application</title>
    	<meta name="Author" content="Mikko Nummelin"/>
    	<meta name="keywords" content="Mikko Nummelin, MZ80TestBench, homepage,
    		Z80, Sinclair, Spectrum, zexall, exerciser, testbench, program,
    		retro-computing, emulator"/>
    	<link href="spectrum.css" rel="stylesheet" type="text/css"/>
    	<meta http-equiv="Content-type" content="text/html; charset=UTF8"/>
	</head>
	
<!-- Try to keep the text less than 80 characters wide ********************* -->

	<body>
	<h1>MZ80TestBench - an open source Z80 test bench application</h1>
	<img src="testbenchsuccess.jpg">MZ80TestBench after successful processor
		feature comparison.</img>
	<hr/>
	<h2>General</h2>
	<p>
		It is often a somewhat difficult task to correctly emulate a processor,
		even a relatively simple one, like Z80. Although it seems simple to
		assign values to registers and memory address, there are anyway lots
		of commands and some of them affect the so-called flags register, F,
		in a strange way. Especially if one uses shortcuts and tries to
		implement a large number of commands in same <code>if</code> construct,
		for example taking advantage of syntax of <code>LD Q,R</code>
		whose binary opcode is in general <code>01QQQRRR</code> where
		<code>Q</code> and <code>R</code> are taken from the following table:
	</p>
		<table border="1" summary="Register-register load instructions"
			align="center">
			<caption>LD Q,R</caption>
			<tr><th>Value of Q or R</th><th>Register / memory pointer</th></tr>
			<tr><td>000</td><td>B</td></tr>
			<tr><td>001</td><td>C</td></tr>
			<tr><td>010</td><td>D</td></tr>
			<tr><td>011</td><td>E</td></tr>
			<tr><td>100</td><td>H</td></tr>
			<tr><td>101</td><td>L</td></tr>
			<tr><td>110</td><td>(HL)</td></tr>
			<tr><td>111</td><td>A</td></tr>
		</table>
	<p>
		Here we have multiple things to be aware of. For example the special
		value <code>110</code> which stands for memory pointer
		<code>(HL)</code> but not a register. To make things more complicated,
		if this type of command is <code>DDh</code> or
		<code>FDh</code>-prefixed, then the command reads or writes from an
		indexed memory reference, ie. the three-byte machine instruction
		"<code>DD 74 E0 </code>" stands for <code>LD (IX-20h),H </code>,
		<i>not</i> <code>LD (IX),H </code>, <code>LD (IX+E0h),H </code> nor
		<code>LD (IX-20h), IXH </code>. Without forgetting that the binary
		code <code>01110110=76h</code> stands for <code>HALT</code>, not any
		sort of load or store command at all! One therefore often needs to
		rely to a verifier, testbench or exerciser against one's own Z80
		emulator, whatever we call it.
	</p>
	<p>
		If at this point you feel that you know nothing what the above is all
		about, please refer to some of the following links:
	</p>
	<ul>
		<li><a href="http://en.wikipedia.org/wiki/Zilog_Z80">Wikipedia: Zilog
			Z80 processor</a></li>
		<li><a href="http://www.z80.info/">Thomas Scherrer: Z80-family official
			support page</a></li>
		<li><a href="http://www.worldofspectrum.org/">World of Spectrum</a>
			</li>
	</ul>
	<hr/>
	
<!-- Try to keep the text less than 80 characters wide ********************* -->
	
	<h2>Z80 emulators compatible with this testbench</h2>
	<p>
		To design your Z80 emulator compatible for this testbench, there is
		just <i>one</i> requirement, it <i>must</i> implement packages
		<a href="../src/main/java/org/mn/z80util/z80/Z80.java">
		Z80-interface</a>. There are two complete examples of such Z80 cores
		here:
	</p>
	<ul>
		<li><a href="../src/main/java/org/mn/z80util/z80/yaze/YazeBasedZ80Impl.java">
		org.mn.z80util.z80.yaze.YazeBasedZ80Impl</a> &amp;
		<a href="../src/main/java/org/mn/z80util/z80/yaze/YazeBasedALU.java">
		org.mn.z80util.z80.yaze.YazeBasedALU</a></li>
		<li><a href="../src/main/java/org/mn/z80util/z80/qaop/QaopZ80Impl.java">
		org.mn.z80util.z80.qaop.QaopZ80Impl</a></li>
	</ul>
	<p>
	The "Yaze"-one is loosely (only central ALU-functions, as the command fork
	in this one is implemented by me!) based on
	<a href="http://www.mathematik.uni-ulm.de/users/ag/yaze-ag/">
	Yaze-AG</a>, many authors, but originally written by Frank D. Cringle. The
	"Qaop"-one is based on <a href="http://wizard.ae.krakow.pl/~jb/qaop/">Qaop</a>,
	which is a Z80 and Sinclair ZX Spectrum emulator written by Jan Bobrowski and
	further based on "The Undocumented Z80 Documented" by Sean Young.
	</p>
	</body>
</html>
